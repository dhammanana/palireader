import re
import unicodedata
"""
Pali Script Converter Library

This library provides functionality to convert Pali text between different scripts.
Converted from JavaScript to Python.
Code was converted from tipitaka.lk node script.
"""

# ISO 15924 script codes
class Script:
    SI = 'Sinh'    # Sinhala
    HI = 'Deva'    # Devanagari
    RO = 'Latn'    # Roman/Latin
    THAI = 'Thai'  # Thai
    LAOS = 'Laoo'  # Lao
    MY = 'Mymr'    # Myanmar
    KM = 'Khmr'    # Khmer
    BENG = 'Beng'  # Bengali
    GURM = 'Guru'  # Gurmukhi
    THAM = 'Lana'  # Tai Tham
    GUJA = 'Gujr'  # Gujarati
    TELU = 'Telu'  # Telugu
    KANN = 'Knda'  # Kannada
    MALA = 'Mlym'  # Malayalam
    BRAH = 'Brah'  # Brahmi
    TIBT = 'Tibt'  # Tibetan
    CYRL = 'Cyrl'  # Cyrillic

SCRIPT_LANG = {
    'Sinh': Script.SI,    # Sinhala
    'Deva': Script.HI,    # Devanagari
    'Latn': Script.RO,    # Roman/Latin
    'Thai': Script.THAI,  # Thai
    'Laoo': Script.LAOS,  # Lao
    'Mymr': Script.MY,    # Myanmar
    'Khmr': Script.KM,    # Khmer
    'Beng': Script.BENG,  # Bengali
    'Guru': Script.GURM,  # Gurmukhi
    'Lana': Script.THAM,  # Tai Tham
    'Gujr': Script.GUJA,  # Gujarati
    'Telu': Script.TELU,  # Telugu
    'Knda': Script.KANN,  # Kannada
    'Mlym': Script.MALA,  # Malayalam
    'Brah': Script.BRAH,  # Brahmi
    'Tibt': Script.TIBT,  # Tibetan
    'Cyrl': Script.CYRL,  # Cyrillic
}

# Script information dictionary
PALI_SCRIPT_INFO = {
    Script.SI: ['Sinhala', 'р╖Гр╖Тр╢Вр╖Др╢╜', [(0x0d80, 0x0dff)], {'locale': 'si', 'localeName': 'р╖Гр╖Тр╢Вр╖Др╢╜'}],
    Script.HI: ['Devanagari', 'рдирд╛рдЧрд░реА', [(0x0900, 0x097f)], {'locale': 'hi', 'localeName': 'рд╣рд┐рдиреНрджреА'}],
    Script.RO: ['Roman', 'Roman', [(0x0000, 0x017f), (0x1e00, 0x1eff)], {'locale': 'en', 'localeName': 'English'}],
    Script.THAI: ['Thai', 'р╣Др╕Чр╕в', [(0x0e00, 0x0e7f), 0xf70f, 0xf700], {'locale': 'th', 'localeName': 'р╣Др╕Чр╕в'}],
    Script.LAOS: ['Laos', 'р║ер║▓р║з', [(0x0e80, 0x0eff)], {'locale': 'lo', 'localeName': 'р║ер║▓р║з'}],
    Script.MY: ['Myanmar', 'сАЧсАЩсАмсАЕсАм', [(0x1000, 0x107f)], {'locale': 'my', 'localeName': 'сАЧсАЩсАмсАЕсАм'}],
    Script.KM: ['Khmer', 'сЮЧсЮ╢сЮЯсЮ╢сЮБсЯТсЮШсЯВсЮЪ', [(0x1780, 0x17ff)], {'locale': 'km', 'localeName': 'сЮЧсЮ╢сЮЯсЮ╢сЮБсЯТсЮШсЯВсЮЪ'}],
    Script.BENG: ['Bengali', 'ржмрж╛ржВрж▓рж╛', [(0x0980, 0x09ff)], {'locale': 'bn', 'localeName': 'ржмрж╛ржВрж▓рж╛', 'group': 'indian'}],
    Script.GURM: ['Gurmukhi', 'риЧрйБри░риорйБриЦрйА', [(0x0a00, 0x0a7f)], {'locale': 'pa', 'localeName': 'рикрй░риЬри╛римрйА', 'group': 'indian'}],
    Script.GUJA: ['Gujarati', 'ркЧрлБркЬрк░рк╛ркдрлА', [(0x0a80, 0x0aff)], {'locale': 'gu', 'localeName': 'ркЧрлБркЬрк░рк╛ркдрлА', 'group': 'indian'}],
    Script.TELU: ['Telugu', 'р░др▒Жр░▓р▒Бр░Чр▒Б', [(0x0c00, 0x0c7f)], {'locale': 'te', 'localeName': 'р░др▒Жр░▓р▒Бр░Чр▒Б', 'group': 'indian'}],
    Script.KANN: ['Kannada', 'р▓Хр▓ир│Нр▓ир▓б', [(0x0c80, 0x0cff)], {'locale': 'kn', 'localeName': 'р▓Хр▓ир│Нр▓ир▓б', 'group': 'indian'}],
    Script.MALA: ['Malayalam', 'р┤ор┤▓р┤пр┤╛р┤│р┤В', [(0x0d00, 0x0d7f)], {'locale': 'ml', 'localeName': 'р┤ор┤▓р┤пр┤╛р┤│р┤В', 'group': 'indian'}],
    Script.THAM: ['Tai Tham', 'Tai Tham LN', [(0x1a20, 0x1aaf)], {'locale': 'th', 'localeName': 'р╣Др╕Чр╕в (Lanna)', 'group': 'other'}],
    Script.BRAH: ['Brahmi', 'Br─Бhm─л', [(0xd804, 0xd804), (0xdc00, 0xdc7f)], {'locale': 'hi', 'localeName': 'рд╣рд┐рдиреНрджреА (Brah)', 'group': 'other'}],
    Script.TIBT: ['Tibetan', 'р╜Цр╜╝р╜Ср╝Лр╜жр╛Рр╜Ср╝Н', [(0x0f00, 0x0fff)], {'locale': 'bo', 'localeName': 'р╜Цр╜╝р╜Ср╝Лр╜жр╛Рр╜Ср╝Н', 'group': 'other'}],
    Script.CYRL: ['Cyrillic', '╨║╨╕╤А╨╕╨╗╨╗╨╕╤Ж╨░', [(0x0400, 0x04ff), (0x0300, 0x036f)], {'locale': 'ru', 'localeName': '╤А╤Г╠Б╤Б╤Б╨║╨╕╨╣', 'group': 'other'}],
}

# Script index dictionary
SCRIPT_INDEX = {
    Script.SI: 0,
    Script.HI: 1,
    Script.RO: 2,
    Script.THAI: 3,
    Script.LAOS: 4,
    Script.MY: 5,
    Script.KM: 6,
    Script.BENG: 7,
    Script.GURM: 8,
    Script.THAM: 9,
    Script.GUJA: 10,
    Script.TELU: 11,
    Script.KANN: 12,
    Script.MALA: 13,
    Script.BRAH: 14,
    Script.TIBT: 15,
    Script.CYRL: 16,
}

# Character mappings
SPECIALS = [
    # independent vowels
    ['р╢Е', 'рдЕ', 'a', 'р╕н', 'р║н', 'сАб', 'сЮв', 'ржЕ', 'риЕ', '\u1A4B', 'ркЕ', 'р░Е', 'р▓Е', 'р┤Е', 'ЁСАЕ', 'р╜и', '╨░'],
    ['р╢Ж', 'рдЖ', '─Б', 'р╕нр╕▓', 'р║нр║▓', 'сАбсАм', 'сЮвсЮ╢', 'ржЖ', 'риЖ', '\u1A4C', 'ркЖ', 'р░Ж', 'р▓Ж', 'р┤Ж', 'ЁСАЖ', 'р╜ир╜▒', '╨░╠Д'],
    ['р╢Й', 'рдЗ', 'i', 'р╕нр╕┤', 'р║нр║┤', 'сАг', 'сЮе', 'ржЗ', 'риЗ', '\u1A4D', 'ркЗ', 'р░З', 'р▓З', 'р┤З', 'ЁСАЗ', 'р╜ир╜▓', '╨╕'],
    ['р╢К', 'рдИ', '─л', 'р╕нр╕╡', 'р║нр║╡', 'сАд', 'сЮж', 'ржИ', 'риИ', '\u1A4E', 'ркИ', 'р░И', 'р▓И', 'р┤И', 'ЁСАИ', 'р╜ир╜▒р╜▓', '╙г'],
    ['р╢Л', 'рдЙ', 'u', 'р╕нр╕╕', 'р║нр║╕', 'сАе', 'сЮз', 'ржЙ', 'риЙ', '\u1A4F', 'ркЙ', 'р░Й', 'р▓Й', 'р┤Й', 'ЁСАЙ', 'р╜ир╜┤', '╤Г'],
    ['р╢М', 'рдК', '┼л', 'р╕нр╕╣', 'р║нр║╣', 'сАж', 'сЮй', 'ржК', 'риК', '\u1A50', 'ркК', 'р░К', 'р▓К', 'р┤К', 'ЁСАК', 'р╜ир╜▒р╜┤', '╙п'],
    ['р╢С', 'рдП', 'e', 'р╕нр╣А', 'р║нр╗А', 'сАз', 'сЮп', 'ржП', 'риП', '\u1A51', 'ркП', 'р░П', 'р▓П', 'р┤П', 'ЁСАП', 'р╜ир╜║', '╨╡'],
    ['р╢Ф', 'рдУ', 'o', 'р╕нр╣В', 'р║нр╗В', 'сАй', 'сЮ▒', 'ржУ', 'риУ', '\u1A52', 'ркУ', 'р░У', 'р▓У', 'р┤У', 'ЁСАС', 'р╜ир╜╝', '╨╛'],
    # various signs
    # niggahita - anusawara
    ['р╢В', 'рдВ', 'с╣Г', '\u0E4D', '\u0ECD', 'сА╢', 'сЯЖ', 'ржВ', 'риВ', '\u1A74', 'ркВ', 'р░В', 'р▓В', 'р┤В', 'ЁСАБ', '\u0F7E', '╨╝╠г'],
    # visarga - not in pali but deva original text has it
    ['р╢Г', 'рдГ', 'с╕е', 'р╕░', 'р║░', 'сА╕', 'сЯЗ', 'ржГ', 'риГ', '\u1A61', 'ркГ', 'р░Г', 'р▓Г', 'р┤Г', 'ЁСАВ', '\u0F7F', '╤Е╠г'],
    # virama (al - hal). roman/cyrillic need special handling
    ['р╖К', 'реН', '', '\u0E3A', '\u0EBA', 'сА╣', 'сЯТ', 'рзН', 'рйН', '\u1A60', 'рлН', 'р▒Н', 'р│Н', 'р╡Н', '\uD804\uDC46', '\u0F84', ''],
    # digits
    ['0', 'реж', '0', 'р╣Р', 'р╗Р', 'сБА', 'сЯа', 'рзж', 'рйж', '\u1A90', 'рлж', 'р▒ж', 'р│ж', 'р╡ж', 'ЁСБж', 'р╝а', '0'],
    ['1', 'рез', '1', 'р╣С', 'р╗С', 'сББ', 'сЯб', 'рзз', 'рйз', '\u1A91', 'рлз', 'р▒з', 'р│з', 'р╡з', 'ЁСБз', 'р╝б', '1'],
    ['2', 'реи', '2', 'р╣Т', 'р╗Т', 'сБВ', 'сЯв', 'рзи', 'рйи', '\u1A92', 'рли', 'р▒и', 'р│и', 'р╡и', 'ЁСБи', 'р╝в', '2'],
    ['3', 'рей', '3', 'р╣У', 'р╗У', 'сБГ', 'сЯг', 'рзй', 'рйй', '\u1A93', 'рлй', 'р▒й', 'р│й', 'р╡й', 'ЁСБй', 'р╝г', '3'],
    ['4', 'рек', '4', 'р╣Ф', 'р╗Ф', 'сБД', 'сЯд', 'рзк', 'рйк', '\u1A94', 'рлк', 'р▒к', 'р│к', 'р╡к', 'ЁСБк', 'р╝д', '4'],
    ['5', 'рел', '5', 'р╣Х', 'р╗Х', 'сБЕ', 'сЯе', 'рзл', 'рйл', '\u1A95', 'рлл', 'р▒л', 'р│л', 'р╡л', 'ЁСБл', 'р╝е', '5'],
    ['6', 'рем', '6', 'р╣Ц', 'р╗Ц', 'сБЖ', 'сЯж', 'рзм', 'рйм', '\u1A96', 'рлм', 'р▒м', 'р│м', 'р╡м', 'ЁСБм', 'р╝ж', '6'],
    ['7', 'рен', '7', 'р╣Ч', 'р╗Ч', 'сБЗ', 'сЯз', 'рзн', 'рйн', '\u1A97', 'рлн', 'р▒н', 'р│н', 'р╡н', 'ЁСБн', 'р╝з', '7'],
    ['8', 'рео', '8', 'р╣Ш', 'р╗Ш', 'сБИ', 'сЯи', 'рзо', 'рйо', '\u1A98', 'рло', 'р▒о', 'р│о', 'р╡о', 'ЁСБо', 'р╝и', '8'],
    ['9', 'реп', '9', 'р╣Щ', 'р╗Щ', 'сБЙ', 'сЯй', 'рзп', 'рйп', '\u1A99', 'рлп', 'р▒п', 'р│п', 'р╡п', 'ЁСБп', 'р╝й', '9'],
]

CONSOS = [
    # velar stops
    ['р╢Ъ', 'рдХ', 'k', 'р╕Б', 'р║Б', 'сАА', 'сЮА', 'ржХ', 'риХ', '\u1A20', 'ркХ', 'р░Х', 'р▓Х', 'р┤Х', 'ЁСАУ', 'р╜А', '╨║'],
    ['р╢Ы', 'рдЦ', 'kh', 'р╕В', 'р║В', 'сАБ', 'сЮБ', 'ржЦ', 'риЦ', '\u1A21', 'ркЦ', 'р░Ц', 'р▓Ц', 'р┤Ц', 'ЁСАФ', 'р╜Б', '╨║╤Е'],
    ['р╢Ь', 'рдЧ', 'g', 'р╕Д', 'р║Д', 'сАВ', 'сЮВ', 'ржЧ', 'риЧ', '\u1A23', 'ркЧ', 'р░Ч', 'р▓Ч', 'р┤Ч', 'ЁСАХ', 'р╜В', '╨│'],
    ['р╢Э', 'рдШ', 'gh', 'р╕Ж', '\u0E86', 'сАГ', 'сЮГ', 'ржШ', 'риШ', '\u1A25', 'ркШ', 'р░Ш', 'р▓Ш', 'р┤Ш', 'ЁСАЦ', 'р╜Вр╛╖', '╨│╤Е'],
    ['р╢Ю', 'рдЩ', 'с╣Е', 'р╕З', 'р║З', 'сАД', 'сЮД', 'ржЩ', 'риЩ', '\u1A26', 'ркЩ', 'р░Щ', 'р▓Щ', 'р┤Щ', 'ЁСАЧ', 'р╜Д', '╨╜╠З'],
    # palatal stops
    ['р╢а', 'рдЪ', 'c', 'р╕И', 'р║И', 'сАЕ', 'сЮЕ', 'ржЪ', 'риЪ', '\u1A27', 'ркЪ', 'р░Ъ', 'р▓Ъ', 'р┤Ъ', 'ЁСАШ', 'р╜Щ', '╤З'],
    ['р╢б', 'рдЫ', 'ch', 'р╕Й', '\u0E89', 'сАЖ', 'сЮЖ', 'ржЫ', 'риЫ', '\u1A28', 'ркЫ', 'р░Ы', 'р▓Ы', 'р┤Ы', 'ЁСАЩ', 'р╜Ъ', '╤З╤Е'],
    ['р╢в', 'рдЬ', 'j', 'р╕К', 'р║К', 'сАЗ', 'сЮЗ', 'ржЬ', 'риЬ', '\u1A29', 'ркЬ', 'р░Ь', 'р▓Ь', 'р┤Ь', 'ЁСАЪ', 'р╜Ы', '╨┤╨╢'],
    ['р╢г', 'рдЭ', 'jh', 'р╕М', '\u0E8C', 'сАИ', 'сЮИ', 'ржЭ', 'риЭ', '\u1A2B', 'ркЭ', 'р░Э', 'р▓Э', 'р┤Э', 'ЁСАЫ', 'р╜Ыр╛╖', '╨┤╨╢╤Е'],
    ['р╢д', 'рдЮ', '├▒', 'р╕Н', '\u0E8E', 'сАЙ', 'сЮЙ', 'ржЮ', 'риЮ', '\u1A2C', 'ркЮ', 'р░Ю', 'р▓Ю', 'р┤Ю', 'ЁСАЬ', 'р╜Й', '╨╜╠Г'],
    # retroflex stops
    ['р╢з', 'рдЯ', 'с╣н', 'р╕П', '\u0E8F', 'сАЛ', 'сЮК', 'ржЯ', 'риЯ', '\u1A2D', 'ркЯ', 'р░Я', 'р▓Я', 'р┤Я', 'ЁСАЭ', 'р╜К', '╤В╠г'],
    ['р╢и', 'рда', 'с╣нh', 'р╕Р', '\u0E90', 'сАМ', 'сЮЛ', 'ржа', 'риа', '\u1A2E', 'рка', 'р░а', 'р▓а', 'р┤а', 'ЁСАЮ', 'р╜Л', '╤В╠г╤Е'],
    ['р╢й', 'рдб', 'с╕Н', 'р╕С', '\u0E91', 'сАН', 'сЮМ', 'ржб', 'риб', '\u1A2F', 'ркб', 'р░б', 'р▓б', 'р┤б', 'ЁСАЯ', 'р╜М', '╨┤╠г'],
    ['р╢к', 'рдв', 'с╕Нh', 'р╕Т', '\u0E92', 'сАО', 'сЮН', 'ржв', 'рив', '\u1A30', 'ркв', 'р░в', 'р▓в', 'р┤в', 'ЁСАа', 'р╜Мр╛╖', '╨┤╠г╤Е'],
    ['р╢л', 'рдг', 'с╣З', 'р╕У', '\u0E93', 'сАП', 'сЮО', 'ржг', 'риг', '\u1A31', 'ркг', 'р░г', 'р▓г', 'р┤г', 'ЁСАб', 'р╜О', '╨╜╠г'],
    # dental stops
    ['р╢н', 'рдд', 't', 'р╕Х', 'р║Х', 'сАР', 'сЮП', 'ржд', 'рид', '\u1A32', 'ркд', 'р░д', 'р▓д', 'р┤д', 'ЁСАв', 'р╜П', '╤В'],
    ['р╢о', 'рде', 'th', 'р╕Ц', 'р║Ц', 'сАС', 'сЮР', 'рже', 'рие', '\u1A33', 'рке', 'р░е', 'р▓е', 'р┤е', 'ЁСАг', 'р╜Р', '╤В╤Е'],
    ['р╢п', 'рдж', 'd', 'р╕Ч', 'р║Ч', 'сАТ', 'сЮС', 'ржж', 'риж', '\u1A34', 'ркж', 'р░ж', 'р▓ж', 'р┤ж', 'ЁСАд', 'р╜С', '╨┤'],
    ['р╢░', 'рдз', 'dh', 'р╕Ш', '\u0E98', 'сАУ', 'сЮТ', 'ржз', 'риз', '\u1A35', 'ркз', 'р░з', 'р▓з', 'р┤з', 'ЁСАе', 'р╜Ср╛╖', '╨┤╤Е'],
    ['р╢▒', 'рди', 'n', 'р╕Щ', 'р║Щ', 'сАФ', 'сЮУ', 'ржи', 'рии', '\u1A36', 'рки', 'р░и', 'р▓и', 'р┤и', 'ЁСАж', 'р╜У', '╨╜'],
    # labial stops
    ['р╢┤', 'рдк', 'p', 'р╕Ы', 'р║Ы', 'сАХ', 'сЮФ', 'ржк', 'рик', '\u1A38', 'ркк', 'р░к', 'р▓к', 'р┤к', 'ЁСАз', 'р╜Ф', '╨┐'],
    ['р╢╡', 'рдл', 'ph', 'р╕Ь', 'р║Ь', 'сАЦ', 'сЮХ', 'ржл', 'рил', '\u1A39', 'ркл', 'р░л', 'р▓л', 'р┤л', 'ЁСАи', 'р╜Х', '╨┐╤Е'],
    ['р╢╢', 'рдм', 'b', 'р╕Ю', 'р║Ю', 'сАЧ', 'сЮЦ', 'ржм', 'рим', '\u1A3B', 'ркм', 'р░м', 'р▓м', 'р┤м', 'ЁСАй', 'р╜Ц', '╨▒'],
    ['р╢╖', 'рдн', 'bh', 'р╕а', '\u0EA0', 'сАШ', 'сЮЧ', 'ржн', 'рин', '\u1A3D', 'ркн', 'р░н', 'р▓н', 'р┤н', 'ЁСАк', 'р╜Цр╛╖', '╨▒╤Е'],
    ['р╢╕', 'рдо', 'm', 'р╕б', 'р║б', 'сАЩ', 'сЮШ', 'ржо', 'рио', '\u1A3E', 'рко', 'р░о', 'р▓о', 'р┤о', 'ЁСАл', 'р╜Ш', '╨╝'],
    # liquids, fricatives, etc.
    ['р╢║', 'рдп', 'y', 'р╕в', 'р║Н', 'сАЪ', 'сЮЩ', 'ржп', 'рип', '\u1A3F', 'ркп', 'р░п', 'р▓п', 'р┤п', 'ЁСАм', 'р╜б', '╨╣'],
    ['р╢╗', 'рд░', 'r', 'р╕г', 'р║г', 'сАЫ', 'сЮЪ', 'рж░', 'ри░', '\u1A41', 'рк░', 'р░░', 'р▓░', 'р┤░', 'ЁСАн', 'р╜в', '╤А'],
    ['р╢╜', 'рд▓', 'l', 'р╕е', 'р║е', 'сАЬ', 'сЮЫ', 'рж▓', 'ри▓', '\u1A43', 'рк▓', 'р░▓', 'р▓▓', 'р┤▓', 'ЁСАо', 'р╜г', '╨╗'],
    ['р╖Е', 'рд│', 'с╕╖', 'р╕м', '\u0EAC', 'сАа', 'сЮб', 'рж▓рж╝', 'ри▓ри╝', '\u1A4A', 'рк│', 'р░│', 'р▓│', 'р┤│', 'ЁСА┤', 'р╜гр╝╣', '╨╗╠г'],
    ['р╖А', 'рд╡', 'v', 'р╕з', 'р║з', 'сАЭ', 'сЮЬ', 'рз░', 'ри╡', '\u1A45', 'рк╡', 'р░╡', 'р▓╡', 'р┤╡', 'ЁСАп', 'р╜Э', '╨▓'],
    ['р╖Г', 'рд╕', 's', 'р╕к', 'р║к', 'сАЮ', 'сЮЯ', 'рж╕', 'ри╕', '\u1A48', 'рк╕', 'р░╕', 'р▓╕', 'р┤╕', 'ЁСА▓', 'р╜ж', '╤Б'],
    ['р╖Д', 'рд╣', 'h', 'р╕л', 'р║л', 'сАЯ', 'сЮа', 'рж╣', 'ри╣', '\u1A49', 'рк╣', 'р░╣', 'р▓╣', 'р┤╣', 'ЁСА│', 'р╜з', '╤Е'],
]

VOWELS = [
    # dependent vowel signs
    ['р╖П', 'рд╛', '─Б', 'р╕▓', 'р║▓', 'сАм', 'сЮ╢', 'рж╛', 'ри╛', '\u1A63', 'рк╛', 'р░╛', 'р▓╛', 'р┤╛', 'ЁСА╕', '\u0F71', '╨░╠Д'],
    ['р╖Т', 'рд┐', 'i', '\u0E34', '\u0EB4', 'сАн', 'сЮ╖', 'рж┐', 'ри┐', '\u1A65', 'рк┐', 'р░┐', 'р▓┐', 'р┤┐', 'ЁСА║', '\u0F72', '╨╕'],
    ['р╖У', 'реА', '─л', '\u0E35', '\u0EB5', 'сАо', 'сЮ╕', 'рзА', 'рйА', '\u1A66', 'рлА', 'р▒А', 'р│А', 'р╡А', 'ЁСА╗', '\u0F71\u0F72', '╙г'],
    ['р╖Ф', 'реБ', 'u', '\u0E38', '\u0EB8', 'сАп', 'сЮ╗', 'рзБ', 'рйБ', '\u1A69', 'рлБ', 'р▒Б', 'р│Б', 'р╡Б', 'ЁСА╝', '\u0F74', '╤Г'],
    ['р╖Ц', 'реВ', '┼л', '\u0E39', '\u0EB9', 'сА░', 'сЮ╝', 'рзВ', 'рйВ', '\u1A6A', 'рлВ', 'р▒В', 'р│В', 'р╡В', 'ЁСА╜', '\u0F71\u0F74', '╙п'],
    # for th/lo - should appear in front
    ['р╖Щ', 'реЗ', 'e', 'р╣А', 'р╗А', 'сА▒', 'сЯБ', 'рзЗ', 'рйЗ', '\u1A6E', 'рлЗ', 'р▒З', 'р│З', 'р╡З', 'ЁСБВ', '\u0F7A', '╨╡'],
    # for th/lo - should appear in front
    ['р╖Ь', 'реЛ', 'o', 'р╣В', 'р╗В', 'сА▒сАм', 'сЯД', 'рзЛ', 'рйЛ', '\u1A6E\u1A63', 'рлЛ', 'р▒Л', 'р│Л', 'р╡Л', 'ЁСБД', '\u0F7C', '╨╛'],
]

# Sinhala consonant range
SINH_CONSO_RANGE = 'р╢Ъ-р╖Ж'
# Thai consonant range
THAI_CONSO_RANGE = 'р╕Б-р╕о'
# Lao consonant range
LAO_CONSO_RANGE = 'р║Б-р║о'
# Myanmar consonant range
MYMR_CONSO_RANGE = 'сАА-сАа'

# Independent vowel to dependent vowel mapping
IV_TO_DV = {
    'р╢Е': '', 'р╢Ж': 'р╖П', 'р╢Й': 'р╖Т', 'р╢К': 'р╖У', 
    'р╢Л': 'р╖Ф', 'р╢М': 'р╖Ц', 'р╢С': 'р╖Щ', 'р╢Ф': 'р╖Ь'
}

def get_script_for_code(char_code):
    """
    Determine the script of a character based on its Unicode code point.
    
    Args:
        char_code: Unicode code point of the character.
        
    Returns:
        Script identifier or -1 if not found.
    """
    for script, info in PALI_SCRIPT_INFO.items():
        for range_info in info[2]:
            if isinstance(range_info, tuple) and char_code >= range_info[0] and char_code <= range_info[1]:
                return script
            elif isinstance(range_info, int) and char_code == range_info:
                return script
    return -1
'''
def prepare_hash_maps(from_index, to_index, use_vowels=True):
    """
    Prepare mapping tables for character conversion.

    Args:
        from_index: Index in the SCRIPT_INDEX for the source script.
        to_index: Index in the SCRIPT_INDEX for the target script.
        use_vowels: Boolean indicating whether to include vowels in the mapping.

    Returns:
        List of tuples, each containing the length of the input character sequence
        and a dictionary mapping input characters to output characters.
    """
    full_array = CONSOS + SPECIALS
    if use_vowels:
        full_array += VOWELS

    final_array = [[], [], []]  # Max 3 for different character lengths
    for val in full_array:
        if from_index < len(val) and from_index > -1:  # Check if the source character exists
            # Group by length of the source character
            final_array[len(val[from_index]) - 1].append((val[from_index], val[to_index]))

    # Filter non-empty arrays, create (length, dict) tuples, and sort by length (descending)
    return [(len(arr[0][0]), dict(arr)) for arr in final_array if arr][::-1]

def replace_by_maps(input_text, hash_maps):
    """
    Replace characters in the input text using the provided mapping tables.

    Args:
        input_text: String to convert.
        hash_maps: List of tuples containing (length, mapping_dict).

    Returns:
        Converted string.
    """
    output_array = []
    b = 0
    while b < len(input_text):
        match = False
        for length, hash_map in hash_maps:
            in_chars = input_text[b:b + length]
            if in_chars in hash_map:
                output_array.append(hash_map[in_chars])  # Can be empty string
                b += length
                match = True
                break
        if not match:
            output_array.append(input_text[b])
            b += 1
    return ''.join(output_array)
'''

def prepare_hash_maps(from_index, to_index, use_vowels=True):
    """
    Prepare mapping tables for character conversion.

    Args:
        from_index: Index in the SCRIPT_INDEX for the source script.
        to_index: Index in the SCRIPT_INDEX for the target script.
        use_vowels: Boolean indicating whether to include vowels in the mapping.

    Returns:
        List of tuples, each containing the length of the input character sequence
        and a dictionary mapping input characters to output characters.
    """
    full_array = CONSOS + SPECIALS
    if use_vowels:
        full_array += VOWELS

    final_array = [[], [], []]  # Max 3 for different character lengths
    for val in full_array:
        if from_index < len(val) and val[from_index]:  # Check if source character exists and is non-empty
            final_array[len(val[from_index]) - 1].append((val[from_index], val[to_index]))

    # Filter non-empty arrays, create (length, dict) tuples, and sort by length (descending)
    return [(len(arr[0][0]), dict(arr)) for arr in final_array if arr][::-1]

def replace_by_maps(input_text, hash_maps):
    """
    Replace characters in the input text using the provided mapping tables.

    Args:
        input_text: String to convert.
        hash_maps: List of tuples containing (length, mapping_dict).

    Returns:
        Converted string.
    """
    output_array = []
    b = 0
    while b < len(input_text):
        match = False
        for length, hash_map in hash_maps:
            if b + length <= len(input_text):  # Ensure we don't go beyond string length
                in_chars = input_text[b:b + length]
                if in_chars in hash_map:
                    output_array.append(hash_map[in_chars])  # Can be empty string
                    b += length
                    match = True
                    break
        if not match:
            output_array.append(input_text[b])  # Copy unmatched character
            b += 1  # Always increment to prevent infinite loop
    return ''.join(output_array)

def insert_a(input_text, script):
    """
    Insert 'a' after consonants not followed by virama, dependent vowel, or 'a'
    in Roman or Cyrillic scripts.

    Args:
        input_text: Input string to process.
        script: Target script identifier.

    Returns:
        Processed string with inserted 'a' characters.
    """
    a = '╨░' if script == Script.CYRL else 'a'
    text = input_text
    # Replace consonant followed by non-vowel/non-virama with consonant + 'a' + next char
    text = re.sub(f'([{SINH_CONSO_RANGE}])([^\\u0DCF-\\u0DDF\\u0DCA{a}])', f'\\1{a}\\2', text)
    text = re.sub(f'([{SINH_CONSO_RANGE}])([^\\u0DCF-\\u0DDF\\u0DCA{a}])', f'\\1{a}\\2', text)
    # Handle consonant at end of string
    text = re.sub(f'([{SINH_CONSO_RANGE}])$', f'\\1{a}', text)
    return text


def remove_a(input_text, script):
    """
    Remove implicit 'a' from consonants and handle independent vowels.

    Args:
        input_text: Input string to process.
        script: Source script identifier.

    Returns:
        Processed string with implicit 'a' removed.
    """
    text = input_text
    vowel_set = ''.join([
        '\u0D85', '\u0D86', '\u0D89', '\u0D8A', '\u0D8B', '\u0D8C', '\u0D91', '\u0D94', '\u0DCA'
    ])
    # Add virama to consonants not followed by vowels or virama
    # text = re.sub(f'([{SINH_CONSO_RANGE}])([^\\u0D85\\u0D86\\u0D89\\u0D8A\\u0D8B\\u0D8C\\u0D91\\u0D94\\u0DCA])',
    #               '\\1\\u0DCA\\2', text)
    # text = re.sub(f'([{SINH_CONSO_RANGE}])([^\\u0D85\\u0D86\\u0D89\\u0D8A\\u0D8B\\u0D8C\\u0D91\\u0D94\\u0DCA])',
    #               '\\1\\u0DCA\\2', text)

    text = re.sub(rf'([{SINH_CONSO_RANGE}])([^{vowel_set}])', r'\1' + chr(0x0DCA) + r'\2', text)
    text = re.sub(rf'([{SINH_CONSO_RANGE}])([^{vowel_set}])', r'\1' + chr(0x0DCA) + r'\2', text)
    text = re.sub(rf'([{SINH_CONSO_RANGE}])$', r'\1' + chr(0x0DCA), text)


    # Handle consonant at end of string
    # text = re.sub(f'([{SINH_CONSO_RANGE}])$', '\\1\\u0DCA', text)
    # Replace consonant + independent vowel with consonant + dependent vowel
    for iv, dv in IV_TO_DV.items():
        text = text.replace(f'([{SINH_CONSO_RANGE}]){iv}', f'\\1{dv}')
    return text

def fix_m_above(text, script):
    """
    Replace 'с╣Б' with Sinhala niggahita (р╢В) per specific request.

    Args:
        text: Input string to process.

    Returns:
        Processed string.
    """
    return text.replace('с╣Б', 'р╢В')

def roman_to_sinhala(text, script):
    """
    Convert Pali Roman script text to Sinhala, handling vowels contextually.

    Args:
        text: Input string in Roman script.
        script: Source script identifier (Script.RO).

    Returns:
        Converted string in Sinhala.
    """
    if script != Script.RO:
        return text  # Only handle Roman script

    # Define mappings
    consonant_map = {c[2]: c[0] for c in CONSOS if c[2]}  # Roman to Sinhala consonants
    special_map = {s[2]: s[0] for s in SPECIALS if s[2]}  # Roman specials (e.g., 'с╣Г' тЖТ 'р╢В')
    vowel_map = {
        'a': '', '─Б': 'р╖П', 'i': 'р╖Т', '─л': 'р╖У', 'u': 'р╖Ф', '┼л': 'р╖Ц', 'e': 'р╖Щ', 'o': 'р╖Ь',
        'A': '', '─А': 'р╖П', 'I': 'р╖Т', '─к': 'р╖У', 'U': 'р╖Ф', '┼к': 'р╖Ц', 'E': 'р╖Щ', 'O': 'р╖Ь'
    }  # Roman vowels to Sinhala dependent vowels
    independent_vowel_map = {
        'a': 'р╢Е', '─Б': 'р╢Ж', 'i': 'р╢Й', '─л': 'р╢К', 'u': 'р╢Л', '┼л': 'р╢М', 'e': 'р╢С', 'o': 'р╢Ф',
        'A': 'р╢Е', '─А': 'р╢Ж', 'I': 'р╢Й', '─к': 'р╢К', 'U': 'р╢Л', '┼к': 'р╢М', 'E': 'р╢С', 'O': 'р╢Ф'
    }

    output = []
    i = 0
    text = un_capitalize(text)  # Convert to lowercase for consistency

    while i < len(text):
        char = text[i]
        next_char = text[i + 1] if i + 1 < len(text) else None

        # Handle special characters (e.g., 'с╣Г')
        if char in special_map and char not in vowel_map:
            output.append(special_map[char])
            i += 1
            continue

        # Check for long vowels (e.g., '─Б')
        if char in 'aiueoAIUEO' and next_char == '╠Д':
            roman_vowel = char + '╠Д'
            i += 2
        else:
            roman_vowel = char
            i += 1

        # Handle vowels
        if roman_vowel in vowel_map:
            # If previous character is a consonant, use dependent vowel
            if output and output[-1] in SINH_CONSO_RANGE:
                output.append(vowel_map[roman_vowel])
            else:
                # Standalone vowel becomes independent
                output.append(independent_vowel_map[roman_vowel])
            continue

        # Handle consonants
        if char in consonant_map:
            output.append(consonant_map[char])
            # If not followed by a vowel, add virama
            if not next_char or (next_char not in vowel_map and next_char != '╠Д'):
                output.append('р╖К')
            continue

        # Unmapped character, append as is
        output.append(char)

    return ''.join(output)



def convert_to(text, script):
    """
    Convert text from Sinhala to another script.

    Args:
        text: Input string in Sinhala.
        script: Target script identifier.

    Returns:
        Converted string.
    """
    hash_maps = prepare_hash_maps(SCRIPT_INDEX[Script.SI], SCRIPT_INDEX[script])
    return replace_by_maps(text, hash_maps)

def convert_from(text, script):
    """
    Convert text from another script to Sinhala.

    Args:
        text: Input string in source script.
        script: Source script identifier.

    Returns:
        Converted string in Sinhala.
    """
    hash_maps = prepare_hash_maps(SCRIPT_INDEX.get(script, -1), SCRIPT_INDEX[Script.SI])
    return replace_by_maps(text, hash_maps)


def convert_from_w_v(text, script):
  
    from_index = SCRIPT_INDEX.get(script, -1)
    if from_index == -1:
        return text  # Return unchanged text if script is invalid
    hash_maps = prepare_hash_maps(from_index, SCRIPT_INDEX[Script.SI], use_vowels=False)
    return replace_by_maps(text, hash_maps)

def beautify_sinh(text, script, rend_type=''):
    """
    Beautify Sinhala text by adjusting joiners.

    Args:
        text: Input string to beautify.
        script: Script identifier.
        rend_type: Rendering type (optional).

    Returns:
        Beautified string.
    """
    return re.sub(r'\u0DCA([\u0DBA\u0DBB])', r'\u0DCA\u200D\1', text)

def un_beautify_sinh(text):
    """
    Undo beautification for Sinhala text.

    Args:
        text: Input string to process.

    Returns:
        Processed string.
    """
    text = text.replace('р╢Т', 'р╢С').replace('р╢Х', 'р╢Ф')
    return text.replace('р╖Ъ', 'р╖Щ').replace('р╖Э', 'р╖Ь')

def beautify_mymr(text, script, rend_type=''):
    """
    Beautify Myanmar text by adjusting punctuation and special characters.

    Args:
        text: Input string to beautify.
        script: Script identifier.
        rend_type: Rendering type (optional).

    Returns:
        Beautified string.
    """
    text = text.replace(r'[,;]', 'сБК')  # Comma/semicolon to single line
    text = re.sub(r'[\u2026\u0964\u0965]+', 'сБЛ', text)  # Ellipsis/danda to double line
    text = text.replace('сАЙ\u1039сАЙ', 'сАК')  # kn + kna to single char
    text = text.replace('сАЮ\u1039сАЮ', 'сА┐')  # s + sa to great sa
    text = re.sub(r'сАДсА╣([сАА-сАа])', r'сАД\u103A\1', text)  # kinzi
    text = text.replace('сА╣сАЪ', 'сА╗')  # yansaya
    text = text.replace('сА╣сАЫ', 'сА╝')  # rakar
    text = text.replace('сА╣сАЭ', 'сА╜')  # wahswe
    text = text.replace('сА╣сАЯ', 'сА╛')  # hahto
    text = re.sub(r'([сАБсАВсАДсАТсАХсАЭ]сА▒?)\u102c', r'\1\u102b', text)  # aa to tall aa
    text = re.sub(r'(сААсА╣сАБ|сАФсА╣сАТ|сАХсА╣сАХ|сАЩсА╣сАХ)(сА▒?)\u102b', r'\1\2\u102c', text)  # restore tall aa
    return re.sub(r'(сАТсА╣сАУ|сАТсА╜)(сА▒?)\u102c', r'\1\2\u102b', text)

def un_beautify_mymr(text):
    """
    Undo beautification for Myanmar text.

    Args:
        text: Input string to process.

    Returns:
        Processed string.
    """
    text = text.replace('\u102B', 'сАм')
    text = text.replace('сА╛', 'сА╣сАЯ')  # hahto
    text = text.replace('сА╜', 'сА╣сАЭ')  # wahswe
    text = text.replace('сА╝', 'сА╣сАЫ')  # rakar
    text = text.replace('сА╗', 'сА╣сАЪ')  # yansaya
    text = text.replace('\u103A', '')  # kinzi
    text = text.replace('сА┐', 'сАЮ\u1039сАЮ')  # great sa
    text = text.replace('сАК', 'сАЙ\u1039сАЙ')  # nnga
    text = text.replace('сАЮсА╢сАГ', 'сАЮсАДсА╣сАГ')  # nigghahita to с╣Е
    text = text.replace('сБК', ',')  # single line to comma
    return text.replace('сБЛ', '.')  # double line to period

def beautify_common(text, script, rend_type=''):
    """
    Apply common beautification steps across scripts.

    Args:
        text: Input string to beautify.
        script: Script identifier.
        rend_type: Rendering type (optional).

    Returns:
        Beautified string.
    """
    if rend_type == 'cen':
        text = text.replace('рее', '')  # Remove double dandas
    elif rend_type.startswith('ga'):
        text = text.replace('ред', ';').replace('рее', '.')  # Single to semicolon, double to period
    text = text.replace('ре░тАж', 'тАж')  # Remove abbreviation before ellipsis
    text = text.replace('ре░', '┬╖')  # Abbreviation to middle dot
    text = text.replace(r'[редрее]', '.')  # Dandas to period
    text = re.sub(r'\s([\s,!;\?\.])', r'\1', text)  # Cleanup spaces
    return text

def un_capitalize(text):
    """
    Convert text to lowercase for Roman script.

    Args:
        text: Input string to process.

    Returns:
        Lowercase string.
    """
    return text.lower()

def swap_e_o(text, script, rend_type=''):
    """
    Swap 'e' and 'o' vowels with preceding consonants in Thai or Lao scripts.

    Args:
        text: Input string to process.
        script: Script identifier.
        rend_type: Rendering type (optional).

    Returns:
        Processed string.
    """
    if script == Script.THAI:
        return re.sub(f'([{THAI_CONSO_RANGE}])([р╣Ар╣В])', r'\2\1', text)
    if script == Script.LAOS:
        return re.sub(f'([{LAO_CONSO_RANGE}])([р╗Ар╗В])', r'\2\1', text)
    raise ValueError(f"Unsupported script {script} for swap_e_o method.")

def un_swap_e_o(text, script):
    """
    Undo swapping of 'e' and 'o' vowels in Thai or Lao scripts.

    Args:
        text: Input string to process.
        script: Source script identifier.

    Returns:
        Processed string.
    """
    if script == Script.THAI:
        return re.sub(f'([р╣Ар╣В])([{THAI_CONSO_RANGE}])', r'\2\1', text)
    if script == Script.LAOS:
        return re.sub(f'([р╗Ар╗В])([{LAO_CONSO_RANGE}])', r'\2\1', text)
    raise ValueError(f"Unsupported script {script} for un_swap_e_o method.")

def beautify_thai(text, script, rend_type=''):
    """
    Beautify Thai text by adjusting special glyphs.

    Args:
        text: Input string to beautify.
        script: Script identifier.

    Returns:
        Beautified string.
    """
    text = text.replace('\u0E34\u0E4D', '\u0E36')  # iс╣Г to single unicode
    text = text.replace('р╕Н', '\uF70F')
    return text.replace('р╕Р', '\uF700')

def un_beautify_thai(text, script):
    """
    Undo beautification for Thai text.

    Args:
        text: Input string to process.
        script: Script identifier.

    Returns:
        Processed string.
    """
    text = text.replace('р╕О', 'р╕П')  # Correct common mistake
    text = text.replace('\u0E36', '\u0E34\u0E4D')  # Split iс╣Г
    text = text.replace('\uF70F', 'р╕Н')
    return text.replace('\uF700', 'р╕Р')

def un_beautify_khmer(text, script):
    """
    Undo beautification for Khmer text.

    Args:
        text: Input string to process.
        script: Script identifier.

    Returns:
        Processed string.
    """
    text = text.replace('\u17B9', '\u17B7\u17C6')  # Split iс╣Г
    return text.replace('\u17D1', '\u17D2')  # End of word virama

def cleanup_zwj(text):
    """
    Remove zero-width joiners from text.

    Args:
        text: Input string to process.

    Returns:
        Processed string.
    """
    return re.sub(r'[\u200C\u200D]', '', text)

def beautify_brahmi(text):
    """
    Beautify Brahmi text by replacing dandas and dashes.

    Args:
        text: Input string to beautify.

    Returns:
        Beautified string.
    """
    text = text.replace('ред', 'ЁСБЗ')
    text = text.replace('рее', 'ЁСБИ')
    return text.replace('тАУ', 'ЁСБЛ')

def beautify_tham(text):
    """
    Beautify Tai Tham text by adjusting special characters.

    Args:
        text: Input string to beautify.

    Returns:
        Beautified string.
    """
    text = text.replace('\u1A60\u1A41', '\u1A55')  # Medial ra
    text = text.replace('\u1A48\u1A60\u1A48', '\u1A54')  # Great sa
    text = text.replace('ред', '\u1AA8')
    return text.replace('рее', '\u1AA9')

def beautify_tibet(text):
    """
    Beautify Tibetan text by adjusting dandas and subjoined consonants.

    Args:
        text: Input string to beautify.

    Returns:
        Beautified string.
    """
    text = text.replace('ред', 'р╝Н')  # Tibetan dandas
    text = text.replace('рее', 'р╝О')
    for i in range(40):
        text = re.sub(chr(0x0F84) + chr(0x0F40 + i), chr(0x0F90 + i), text)
    text = text.replace('\u0F61\u0FB1', '\u0F61\u0FBB')  # yya
    text = text.replace('\u0F5D\u0FAD', '\u0F5D\u0FBA')  # vva
    text = text.replace('\u0F5B\u0FAC', '\u0F5B\u0F84\u0F5C')  # jjha
    text = text.replace('\u0F61\u0FB7', '\u0F61\u0F84\u0F67')  # yha
    return text.replace('\u0F5D\u0FB7', '\u0F5D\u0F84\u0F67')  # vha

def un_beautify_tibet(text):
    """
    Undo beautification for Tibetan text (placeholder).

    Args:
        text: Input string to process.

    Returns:
        Processed string.
    """
    return text  # TODO: Implement if needed

# Function mappings
CONVERT_TO_FUNC_DEFAULT = [convert_to]
CONVERT_TO_FUNC = {
    Script.SI: [],
    Script.RO: [insert_a, convert_to],
    Script.CYRL: [insert_a, convert_to],
}

CONVERT_FROM_FUNC_DEFAULT = [convert_from]
# CONVERT_FROM_FUNC = {
#     Script.SI: [],
#     Script.RO: [convert_from_w_v, fix_m_above, remove_a],
#     Script.CYRL: [convert_from_w_v, remove_a],
# }

# Update CONVERT_FROM_FUNC for Roman script
CONVERT_FROM_FUNC = {
    Script.SI: [],
    Script.RO: [roman_to_sinhala, fix_m_above],  # Replace old pipeline
    Script.CYRL: [convert_from_w_v, remove_a],
}

BEAUTIFY_FUNC_DEFAULT = []
BEAUTIFY_FUNC = {
    Script.SI: [beautify_sinh, beautify_common],
    Script.RO: [beautify_common],
    Script.THAI: [swap_e_o, beautify_thai, beautify_common],
    Script.LAOS: [swap_e_o, beautify_common],
    Script.MY: [beautify_mymr, beautify_common],
    Script.KM: [beautify_common],
    Script.THAM: [beautify_tham],
    Script.GUJA: [beautify_common],
    Script.TELU: [beautify_common],
    Script.MALA: [beautify_common],
    Script.BRAH: [beautify_brahmi, beautify_common],
    Script.TIBT: [beautify_tibet],
    Script.CYRL: [beautify_common],
}

UN_BEAUTIFY_FUNC_DEFAULT = []
UN_BEAUTIFY_FUNC = {
    Script.SI: [cleanup_zwj, un_beautify_sinh],
    Script.HI: [cleanup_zwj],
    Script.RO: [un_capitalize],
    Script.THAI: [un_beautify_thai, un_swap_e_o],
    Script.LAOS: [un_swap_e_o],
    Script.KM: [un_beautify_khmer],
    Script.MY: [un_beautify_mymr],
    Script.TIBT: [un_beautify_tibet],
}

class TextProcessor:
    """
    A class to handle Pali text conversion and beautification between scripts.
    """
    @staticmethod
    def basic_convert_from_sinh(input_text, script):
        """
        Convert text from Sinhala to another script.

        Args:
            input_text: Input string in Sinhala.
            script: Target script identifier.

        Returns:
            Converted string.
        """
        text = input_text
        for func in CONVERT_TO_FUNC.get(script, CONVERT_TO_FUNC_DEFAULT):
            text = func(text, script)
        return text

    @staticmethod
    def basic_convert_to_sinh(input_text, script):
        """
        Convert text from another script to Sinhala.

        Args:
            input_text: Input string in source script.
            script: Source script identifier.

        Returns:
            Converted string in Sinhala.
        """
        text = input_text
        for func in CONVERT_FROM_FUNC.get(script, CONVERT_FROM_FUNC_DEFAULT):
            text = func(text, script)
        return text

    @staticmethod
    def beautify(input_text, script, rend_type=''):
        """
        Apply script-specific beautification.

        Args:
            input_text: Input string to beautify.
            script: Script identifier.
            rend_type: Rendering type (optional).

        Returns:
            Beautified string.
        """
        text = input_text
        for func in BEAUTIFY_FUNC.get(script, BEAUTIFY_FUNC_DEFAULT):
            text = func(text, script, rend_type)
        return text

    @staticmethod
    def convert_from_sinh(input_text, script):
        """
        Convert and beautify text from Sinhala to another script.

        Args:
            input_text: Input string in Sinhala.
            script: Target script identifier.

        Returns:
            Converted and beautified string.
        """
        text = TextProcessor.basic_convert_from_sinh(input_text, script)
        return TextProcessor.beautify(text, script)

    @staticmethod
    def convert_to_sinh(input_text, script):
        """
        Convert and unbeautify text from another script to Sinhala.

        Args:
            input_text: Input string in source script.
            script: Source script identifier.

        Returns:
            Converted string in Sinhala.
        """
        text = input_text
        for func in UN_BEAUTIFY_FUNC.get(script, UN_BEAUTIFY_FUNC_DEFAULT):
            text = func(text)
        return TextProcessor.basic_convert_to_sinh(text, script)

    @staticmethod
    def convert_any_to_sinh(input_text):
        """
        Convert mixed-script text to Sinhala.

        Args:
            input_text: Input string with mixed scripts.

        Returns:
            Converted string in Sinhala.
        """
        mixed_text = cleanup_zwj(input_text) + ' '  # Handle ZWJ and add space for last char
        cur_script = -1
        run = ''
        output = ''
        for char in mixed_text:
            new_script = get_script_for_code(ord(char))
            if new_script != cur_script or char == mixed_text[-1]:
                output += TextProcessor.convert_to_sinh(run, cur_script)
                cur_script = new_script
                run = char
            else:
                run += char
        return output
        

def myanmar_to_roman(myanmar):
    sinh = TextProcessor.convert_to_sinh(myanmar, Script.MY)
    roman = TextProcessor.convert_from_sinh(sinh, Script.RO)
    return roman


def roman_to_sinhala1(text):
    """
    Convert Pali Roman script to Sinhala.

    Args:
        text: Input string in Pali Roman script (e.g., 'saс╣Гvaс╣Зс╣Зan─Б').
    
    Returns:
        String in Sinhala script (e.g., 'р╖Гр╢Вр╖Ар╢лр╖Кр╢лр╢▒р╖П').
    """
    # Normalize to NFC to handle precomposed characters
    text = unicodedata.normalize('NFC', text.lower())

    # Define mappings
    consonant_map = {
        'k': 'р╢Ъ', 'g': 'р╢Ь', 'c': 'р╢а', 'j': 'р╢в', 'с╣н': 'р╢з', 'с╕Н': 'р╢й', 't': 'р╢н',
        'd': 'р╢п', 'p': 'р╢┤', 'b': 'р╢╢', 'm': 'р╢╕', 'y': 'р╢║', 'r': 'р╢╗', 'l': 'р╢╜',
        'v': 'р╖А', 's': 'р╖Г', 'h': 'р╖Д', 'n': 'р╢▒', '├▒': 'р╢д', 'с╣Е': 'р╢Ю', 'с╣З': 'р╢л',
        'с╕╖': 'р╖Е'
    }
    special_map = {'с╣Г': 'р╢В', 'с╣Б': 'р╢В'}  # Handle both 'с╣Г' and 'с╣Б' for anusvara
    vowel_map = {
        'a': '', '─Б': 'р╖П', 'i': 'р╖Т', '─л': 'р╖У', 'u': 'р╖Ф', '┼л': 'р╖Ц', 'e': 'р╖Щ', 'o': 'р╖Ь'
    }
    independent_vowel_map = {
        'a': 'р╢Е', '─Б': 'р╢Ж', 'i': 'р╢Й', '─л': 'р╢К', 'u': 'р╢Л', '┼л': 'р╢М', 'e': 'р╢С', 'o': 'р╢Ф'
    }

    output = []
    i = 0
    while i < len(text):
        char = text[i]
        next_char = text[i + 1] if i + 1 < len(text) else None

        # Handle special characters
        if char in special_map:
            output.append(special_map[char])
            i += 1
            continue

        # Handle long vowels (e.g., '─Б', '─л')
        if char in 'aiueo' and next_char == '╠Д':
            char = char + '╠Д'
            i += 2
        else:
            i += 1

        # Handle vowels
        if char in vowel_map:
            # Use dependent vowel if last character is a consonant
            if output and 'р╢Ъ' <= output[-1] <= 'р╖Ж':
                output.append(vowel_map[char])
            else:
                output.append(independent_vowel_map[char])
            continue

        # Handle consonants
        if char in consonant_map:
            output.append(consonant_map[char])
            # Add virama if next character is a consonant or special character
            if next_char and (next_char in consonant_map or next_char in special_map):
                output.append('р╖К')
            continue

        # Append unmapped characters (e.g., spaces, punctuation)
        output.append(char)

    return ''.join(output)

def roman_to_sinhala(text):
    from aksharamukha import transliterate
    sinhala_text = transliterate.process('IAST', 'Sinhala', text, post_options=['SinhalaPali'])
    return sinhala_text



if __name__ == '__main__':
    sin = "р╢пр╢вр╖Кр╢вр╖Щр╢║р╖КтАНр╢║р╖Фр╢В"
    ori_roman = 'dajjeyyuс╣Г'
    # sinh = TextProcessor.convert_to_sinh(ori_roman, Script.RO)
    sinh = roman_to_sinhala(ori_roman)
    print(sinh)
    # roman = TextProcessor.convert_from_sinh(sin, Script.RO)

    if sinh in sin:
        print("OKKKK")
    else:
        print(sin)
